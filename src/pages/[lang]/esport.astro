---
// Import du layout standard
import Layout from "../../layouts/layout.astro";
import { Picture } from "astro:assets";
import CtaDispo from "../../components/cta_dispo.astro";

// Images du projet (√† adapter selon votre structure)
import esportImage from "../../assets/projects/esport01.png";
import esportImage2 from "../../assets/projects/esport01.png";
import esportImage3 from "../../assets/projects/esport01.png";
import esportImage4 from "../../assets/projects/esport01.png";

// R√©cup√©rer le param√®tre de langue depuis l'URL
export function getStaticPaths() {
  return [
    { params: { lang: "fr" } },
    { params: { lang: "en" } },
    { params: { lang: "de" } },
  ];
}

const lang = Astro.params.lang as "fr" | "en" | "de";

// Contenu traduit pour chaque langue
const content = {
  fr: {
    title: "Application e-sport avec chat | Josselin HANEL",
    description: "Plateforme de gestion d'√©v√©nements e-sport int√©grant un syst√®me de chat en temps r√©el via WebSocket et HTMX.",
    projectTitle: "Application e-sport avec chat",
    projectIntro: "Cette plateforme permet aux organisateurs d'√©v√©nements e-sport de cr√©er et g√©rer des tournois, tout en offrant aux participants un moyen de communiquer en temps r√©el via un syst√®me de chat int√©gr√©.",
    
    overviewTitle: "Aper√ßu du projet",
    overviewText: "Ce projet d√©montre l'int√©gration d'un chat en temps r√©el dans une application web avec une architecture claire s√©parant les responsabilit√©s. Le frontend utilise Astro pour le rendu statique avec des √Ælots interactifs via Alpine.js et HTMX, tandis que le backend est divis√© en deux services : un serveur Express pour l'API REST et un serveur WebSocket d√©di√© pour la communication en temps r√©el.",

    architectureTitle: "Architecture du projet",
    frontendTitle: "Frontend",
    frontendDetails: [
      "Astro pour le rendu statique avec hydratation partielle",
      "Alpine.js pour la gestion de l'√©tat local et les interactions UI l√©g√®res",
      "HTMX pour les requ√™tes AJAX et l'interaction avec le serveur sans JavaScript complexe",
      "Tailwind CSS pour un styling efficace avec des classes utilitaires"
    ],
    backendTitle: "Backend",
    backendDetails: [
      "Architecture en services s√©par√©s pour une meilleure s√©paration des responsabilit√©s",
      "Service Express pour l'API REST (authentification, CRUD des √©v√©nements et tournois)",
      "Service WebSocket d√©di√© pour la communication en temps r√©el du chat",
      "MongoDB pour le stockage des messages et des donn√©es utilisateurs",
      "PostgreSQL pour les donn√©es structur√©es (√©v√©nements, tournois, √©quipes)"
    ],
    
    componentInteractionTitle: "Interaction des composants",
    componentInteractions: [
      {
        title: "Serveur Express (API REST)",
        role: "G√®re toutes les op√©rations CRUD classiques",
        responsibilities: [
          "Authentification et gestion des utilisateurs",
          "Cr√©ation et gestion des √©v√©nements e-sport",
          "Configuration des tournois et des √©quipes",
          "Stockage des donn√©es persistantes dans PostgreSQL"
        ]
      },
      {
        title: "Serveur WebSocket",
        role: "G√®re exclusivement la communication en temps r√©el",
        responsibilities: [
          "√âtablissement et maintien des connexions WebSocket",
          "Diffusion des messages dans les salons de discussion appropri√©s",
          "Notification des √©v√©nements en direct (d√©but de match, r√©sultats)",
          "Stockage temporaire des messages dans MongoDB pour une r√©cup√©ration facile"
        ]
      },
      {
        title: "Frontend HTMX + Alpine.js",
        role: "Interface utilisateur r√©active avec un minimum de JavaScript",
        responsibilities: [
          "HTMX intercepte les formulaires et effectue des requ√™tes AJAX vers l'API Express",
          "HTMX se connecte au WebSocket pour les messages en temps r√©el",
          "Alpine.js g√®re l'√©tat local et les interactions UI complexes",
          "Astro optimise le chargement initial avec le rendu c√¥t√© serveur"
        ]
      }
    ],
    
    challengesTitle: "D√©fis techniques",
    challenges: [
      {
        title: "S√©paration des services",
        description: "Concevoir une architecture o√π Express et WebSocket fonctionnent comme des services ind√©pendants tout en permettant une communication fluide entre eux."
      },
      {
        title: "Gestion d'√©tat distribu√©e",
        description: "Maintenir la coh√©rence des donn√©es entre le frontend et les deux services backend (REST et WebSocket)."
      },
      {
        title: "Performance et mise √† l'√©chelle",
        description: "Optimiser le serveur WebSocket pour g√©rer des centaines de connexions simultan√©es sans d√©gradation des performances."
      },
      {
        title: "S√©curit√© inter-services",
        description: "Mettre en place un syst√®me d'authentification coh√©rent entre l'API REST et le service WebSocket."
      }
    ],
    
    solutionsTitle: "Solutions mises en ≈ìuvre",
    solutions: [
      {
        title: "Architecture en microservices l√©gers",
        description: "Les services Express et WebSocket sont d√©velopp√©s comme des unit√©s ind√©pendantes avec des responsabilit√©s clairement d√©finies, mais partagent des utilitaires communs (authentification, configuration)."
      },
      {
        title: "Messaging Pattern",
        description: "Utilisation d'un syst√®me de publication/abonnement pour permettre la communication entre les services Express et WebSocket lorsque n√©cessaire."
      },
      {
        title: "HTMX pour la simplicit√©",
        description: "HTMX permet d'obtenir une exp√©rience dynamique semblable √† une SPA mais avec beaucoup moins de JavaScript c√¥t√© client, rendant l'application plus l√©g√®re et r√©active."
      },
      {
        title: "WebSocket optimis√©",
        description: "Le serveur WebSocket utilise une architecture √©v√©nementielle non-bloquante et impl√©mente des strat√©gies d'optimisation comme le batching des messages et la compression."
      }
    ],
    
    lessonsTitle: "Le√ßons apprises",
    lessons: [
      "La s√©paration des responsabilit√©s entre diff√©rents services backend am√©liore consid√©rablement la maintenabilit√© et l'√©volutivit√© de l'application",
      "HTMX et WebSocket forment une combinaison puissante pour cr√©er des interfaces dynamiques avec peu de JavaScript",
      "L'utilisation de bases de donn√©es sp√©cialis√©es pour diff√©rents types de donn√©es (PostgreSQL pour les donn√©es structur√©es, MongoDB pour les messages) permet d'optimiser les performances",
      "Une bonne documentation des API et des interfaces entre services est essentielle dans une architecture distribu√©e"
    ],
    
    performanceTitle: "Performance et optimisations",
    performance: [
      {
        metric: "Temps de chargement initial",
        value: "< 1.2s",
        optimization: "Rendu c√¥t√© serveur avec Astro, hydratation partielle uniquement des composants interactifs"
      },
      {
        metric: "Taille du bundle JS",
        value: "92 KB (non minifi√©)",
        optimization: "Utilisation minimale de JavaScript gr√¢ce √† HTMX et Alpine.js"
      },
      {
        metric: "Latence des messages",
        value: "< 100ms",
        optimization: "Architecture WebSocket optimis√©e avec mise en cache"
      },
      {
        metric: "Score Lighthouse Performance",
        value: "94/100",
        optimization: "Images optimis√©es, CSS minifi√©, chargement diff√©r√© des ressources non critiques"
      }
    ],
    
    techTitle: "Technologies utilis√©es",
    backendFrontendTitle: "S√©paration Backend/Frontend",
    
    visitSite: "Visiter le prototype",
    viewSourceCode: "Voir le code source",
    nextProject: "Projet suivant",
    prevProject: "Projet pr√©c√©dent",
    allProjects: "Tous les projets",
    
    reflectionTitle: "R√©flexion personnelle",
    reflectionText: "Ce projet a √©t√© une excellente occasion d'explorer une architecture en services s√©par√©s avec des responsabilit√©s distinctes. L'utilisation conjointe d'Express pour l'API REST et d'un serveur WebSocket d√©di√© pour la communication en temps r√©el s'est av√©r√©e √™tre une solution √©l√©gante et performante. J'ai particuli√®rement appr√©ci√© l'int√©gration de HTMX qui permet d'obtenir une exp√©rience utilisateur dynamique avec un minimum de JavaScript, tout en conservant une architecture propre c√¥t√© serveur. √Ä l'avenir, j'aimerais approfondir les aspects de mise √† l'√©chelle et explorer des solutions comme Redis pour la communication inter-services."
  },
  en: {
    title: "E-sport Application with Chat | Josselin HANEL",
    description: "E-sport event management platform with a real-time chat system via WebSocket and HTMX.",
    projectTitle: "E-sport Application with Chat",
    projectIntro: "This platform allows e-sport event organizers to create and manage tournaments, while offering participants a way to communicate in real-time via an integrated chat system.",
    
    overviewTitle: "Project overview",
    overviewText: "This project demonstrates the integration of real-time chat into a web application with a clear architecture separating responsibilities. The frontend uses Astro for static rendering with interactive islands via Alpine.js and HTMX, while the backend is divided into two services: an Express server for the REST API and a dedicated WebSocket server for real-time communication.",

    architectureTitle: "Project architecture",
    frontendTitle: "Frontend",
    frontendDetails: [
      "Astro for static rendering with partial hydration",
      "Alpine.js for local state management and lightweight UI interactions",
      "HTMX for AJAX requests and server interaction without complex JavaScript",
      "Tailwind CSS for efficient styling with utility classes"
    ],
    backendTitle: "Backend",
    backendDetails: [
      "Architecture in separate services for better separation of concerns",
      "Express service for the REST API (authentication, CRUD for events and tournaments)",
      "Dedicated WebSocket service for real-time chat communication",
      "MongoDB for storing messages and user data",
      "PostgreSQL for structured data (events, tournaments, teams)"
    ],
    
    componentInteractionTitle: "Component interaction",
    componentInteractions: [
      {
        title: "Express Server (REST API)",
        role: "Handles all classic CRUD operations",
        responsibilities: [
          "Authentication and user management",
          "Creation and management of e-sport events",
          "Configuration of tournaments and teams",
          "Persistent data storage in PostgreSQL"
        ]
      },
      {
        title: "WebSocket Server",
        role: "Exclusively manages real-time communication",
        responsibilities: [
          "Establishment and maintenance of WebSocket connections",
          "Broadcasting messages in appropriate chat rooms",
          "Notification of live events (match start, results)",
          "Temporary storage of messages in MongoDB for easy retrieval"
        ]
      },
      {
        title: "Frontend HTMX + Alpine.js",
        role: "Responsive user interface with minimal JavaScript",
        responsibilities: [
          "HTMX intercepts forms and makes AJAX requests to the Express API",
          "HTMX connects to WebSocket for real-time messages",
          "Alpine.js handles local state and complex UI interactions",
          "Astro optimizes initial loading with server-side rendering"
        ]
      }
    ],
    
    challengesTitle: "Technical challenges",
    challenges: [
      {
        title: "Service separation",
        description: "Designing an architecture where Express and WebSocket work as independent services while allowing smooth communication between them."
      },
      {
        title: "Distributed state management",
        description: "Maintaining data consistency between the frontend and the two backend services (REST and WebSocket)."
      },
      {
        title: "Performance and scaling",
        description: "Optimizing the WebSocket server to handle hundreds of simultaneous connections without performance degradation."
      },
      {
        title: "Inter-service security",
        description: "Implementing a consistent authentication system between the REST API and the WebSocket service."
      }
    ],
    
    solutionsTitle: "Implemented solutions",
    solutions: [
      {
        title: "Lightweight microservices architecture",
        description: "Express and WebSocket services are developed as independent units with clearly defined responsibilities, but share common utilities (authentication, configuration)."
      },
      {
        title: "Messaging Pattern",
        description: "Use of a publish/subscribe system to enable communication between Express and WebSocket services when necessary."
      },
      {
        title: "HTMX for simplicity",
        description: "HTMX provides a dynamic SPA-like experience but with much less client-side JavaScript, making the application lighter and more responsive."
      },
      {
        title: "Optimized WebSocket",
        description: "The WebSocket server uses a non-blocking event-driven architecture and implements optimization strategies such as message batching and compression."
      }
    ],
    
    lessonsTitle: "Lessons learned",
    lessons: [
      "Separating responsibilities between different backend services greatly improves the maintainability and scalability of the application",
      "HTMX and WebSocket form a powerful combination for creating dynamic interfaces with little JavaScript",
      "Using specialized databases for different types of data (PostgreSQL for structured data, MongoDB for messages) optimizes performance",
      "Good documentation of APIs and interfaces between services is essential in a distributed architecture"
    ],
    
    performanceTitle: "Performance and optimizations",
    performance: [
      {
        metric: "Initial load time",
        value: "< 1.2s",
        optimization: "Server-side rendering with Astro, partial hydration only of interactive components"
      },
      {
        metric: "JS bundle size",
        value: "92 KB (unminified)",
        optimization: "Minimal JavaScript usage thanks to HTMX and Alpine.js"
      },
      {
        metric: "Message latency",
        value: "< 100ms",
        optimization: "Optimized WebSocket architecture with caching"
      },
      {
        metric: "Lighthouse Performance Score",
        value: "94/100",
        optimization: "Optimized images, minified CSS, lazy loading of non-critical resources"
      }
    ],
    
    techTitle: "Technologies used",
    backendFrontendTitle: "Backend/Frontend Separation",
    
    visitSite: "Visit prototype",
    viewSourceCode: "View source code",
    nextProject: "Next project",
    prevProject: "Previous project",
    allProjects: "All projects",
    
    reflectionTitle: "Personal reflection",
    reflectionText: "This project was an excellent opportunity to explore a service-separated architecture with distinct responsibilities. The combined use of Express for the REST API and a dedicated WebSocket server for real-time communication proved to be an elegant and performant solution. I particularly appreciated the integration of HTMX, which provides a dynamic user experience with minimal JavaScript, while maintaining a clean server-side architecture. In the future, I would like to delve deeper into scaling aspects and explore solutions like Redis for inter-service communication."
  },
  de: {
    title: "E-Sport-Anwendung mit Chat | Josselin HANEL",
    description: "E-Sport-Eventmanagement-Plattform mit einem Echtzeit-Chat-System √ºber WebSocket und HTMX.",
    projectTitle: "E-Sport-Anwendung mit Chat",
    projectIntro: "Diese Plattform erm√∂glicht es E-Sport-Veranstaltern, Turniere zu erstellen und zu verwalten, w√§hrend sie den Teilnehmern eine M√∂glichkeit bietet, √ºber ein integriertes Chat-System in Echtzeit zu kommunizieren.",
    
    overviewTitle: "Projekt√ºbersicht",
    overviewText: "Dieses Projekt demonstriert die Integration eines Echtzeit-Chats in eine Webanwendung mit einer klaren Architektur, die Verantwortlichkeiten trennt. Das Frontend verwendet Astro f√ºr statisches Rendering mit interaktiven Inseln √ºber Alpine.js und HTMX, w√§hrend das Backend in zwei Dienste unterteilt ist: einen Express-Server f√ºr die REST-API und einen dedizierten WebSocket-Server f√ºr die Echtzeit-Kommunikation.",

    architectureTitle: "Projektarchitektur",
    frontendTitle: "Frontend",
    frontendDetails: [
      "Astro f√ºr statisches Rendering mit partieller Hydratation",
      "Alpine.js f√ºr lokale Zustandsverwaltung und leichtgewichtige UI-Interaktionen",
      "HTMX f√ºr AJAX-Anfragen und Serverinteraktion ohne komplexes JavaScript",
      "Tailwind CSS f√ºr effizientes Styling mit Utility-Klassen"
    ],
    backendTitle: "Backend",
    backendDetails: [
      "Architektur in separaten Diensten f√ºr bessere Trennung der Zust√§ndigkeiten",
      "Express-Dienst f√ºr die REST-API (Authentifizierung, CRUD f√ºr Veranstaltungen und Turniere)",
      "Dedizierter WebSocket-Dienst f√ºr Echtzeit-Chat-Kommunikation",
      "MongoDB f√ºr die Speicherung von Nachrichten und Benutzerdaten",
      "PostgreSQL f√ºr strukturierte Daten (Veranstaltungen, Turniere, Teams)"
    ],
    
    componentInteractionTitle: "Komponenteninteraktion",
    componentInteractions: [
      {
        title: "Express-Server (REST-API)",
        role: "Behandelt alle klassischen CRUD-Operationen",
        responsibilities: [
          "Authentifizierung und Benutzerverwaltung",
          "Erstellung und Verwaltung von E-Sport-Veranstaltungen",
          "Konfiguration von Turnieren und Teams",
          "Persistente Datenspeicherung in PostgreSQL"
        ]
      },
      {
        title: "WebSocket-Server",
        role: "Verwaltet ausschlie√ülich die Echtzeit-Kommunikation",
        responsibilities: [
          "Einrichtung und Wartung von WebSocket-Verbindungen",
          "√úbertragung von Nachrichten in entsprechenden Chatrooms",
          "Benachrichtigung √ºber Live-Events (Spielbeginn, Ergebnisse)",
          "Tempor√§re Speicherung von Nachrichten in MongoDB f√ºr einfachen Abruf"
        ]
      },
      {
        title: "Frontend HTMX + Alpine.js",
        role: "Responsive Benutzeroberfl√§che mit minimalem JavaScript",
        responsibilities: [
          "HTMX f√§ngt Formulare ab und stellt AJAX-Anfragen an die Express-API",
          "HTMX verbindet sich mit WebSocket f√ºr Echtzeit-Nachrichten",
          "Alpine.js verwaltet lokalen Zustand und komplexe UI-Interaktionen",
          "Astro optimiert das initiale Laden mit serverseitigem Rendering"
        ]
      }
    ],
    
    challengesTitle: "Technische Herausforderungen",
    challenges: [
      {
        title: "Dienste-Trennung",
        description: "Entwicklung einer Architektur, in der Express und WebSocket als unabh√§ngige Dienste funktionieren und gleichzeitig eine reibungslose Kommunikation zwischen ihnen erm√∂glicht wird."
      },
      {
        title: "Verteilte Zustandsverwaltung",
        description: "Aufrechterhaltung der Datenkonsistenz zwischen dem Frontend und den beiden Backend-Diensten (REST und WebSocket)."
      },
      {
        title: "Leistung und Skalierung",
        description: "Optimierung des WebSocket-Servers zur Bew√§ltigung von Hunderten gleichzeitiger Verbindungen ohne Leistungseinbu√üen."
      },
      {
        title: "Dienste√ºbergreifende Sicherheit",
        description: "Implementierung eines konsistenten Authentifizierungssystems zwischen der REST-API und dem WebSocket-Dienst."
      }
    ],
    
    solutionsTitle: "Umgesetzte L√∂sungen",
    solutions: [
      {
        title: "Leichtgewichtige Microservices-Architektur",
        description: "Express- und WebSocket-Dienste werden als unabh√§ngige Einheiten mit klar definierten Verantwortlichkeiten entwickelt, teilen aber gemeinsame Dienstprogramme (Authentifizierung, Konfiguration)."
      },
      {
        title: "Messaging-Pattern",
        description: "Verwendung eines Publish/Subscribe-Systems zur Erm√∂glichung der Kommunikation zwischen Express- und WebSocket-Diensten bei Bedarf."
      },
      {
        title: "HTMX f√ºr Einfachheit",
        description: "HTMX bietet ein dynamisches SPA-√§hnliches Erlebnis, aber mit viel weniger clientseitigem JavaScript, wodurch die Anwendung leichter und reaktionsschneller wird."
      },
      {
        title: "Optimierter WebSocket",
        description: "Der WebSocket-Server verwendet eine nicht-blockierende, ereignisgesteuerte Architektur und implementiert Optimierungsstrategien wie Message-Batching und Kompression."
      }
    ],
    
    lessonsTitle: "Gelernte Lektionen",
    lessons: [
      "Die Trennung der Verantwortlichkeiten zwischen verschiedenen Backend-Diensten verbessert erheblich die Wartbarkeit und Skalierbarkeit der Anwendung",
      "HTMX und WebSocket bilden eine leistungsstarke Kombination zur Erstellung dynamischer Schnittstellen mit wenig JavaScript",
      "Die Verwendung spezialisierter Datenbanken f√ºr verschiedene Arten von Daten (PostgreSQL f√ºr strukturierte Daten, MongoDB f√ºr Nachrichten) optimiert die Leistung",
      "Eine gute Dokumentation von APIs und Schnittstellen zwischen Diensten ist in einer verteilten Architektur unerl√§sslich"
    ],
    
    performanceTitle: "Leistung und Optimierungen",
    performance: [
      {
        metric: "Initiale Ladezeit",
        value: "< 1,2s",
        optimization: "Serverseitiges Rendering mit Astro, partielle Hydratation nur f√ºr interaktive Komponenten"
      },
      {
        metric: "JS-Bundle-Gr√∂√üe",
        value: "92 KB (nicht minifiziert)",
        optimization: "Minimale JavaScript-Nutzung dank HTMX und Alpine.js"
      },
      {
        metric: "Nachrichtenlatenz",
        value: "< 100ms",
        optimization: "Optimierte WebSocket-Architektur mit Caching"
      },
      {
        metric: "Lighthouse Performance Score",
        value: "94/100",
        optimization: "Optimierte Bilder, minifiziertes CSS, Lazy Loading nicht-kritischer Ressourcen"
      }
    ],
    
    techTitle: "Verwendete Technologien",
    backendFrontendTitle: "Backend/Frontend-Trennung",
    
    visitSite: "Prototyp besuchen",
    viewSourceCode: "Quellcode ansehen",
    nextProject: "N√§chstes Projekt",
    prevProject: "Vorheriges Projekt",
    allProjects: "Alle Projekte",
    
    reflectionTitle: "Pers√∂nliche Reflexion",
    reflectionText: "Dieses Projekt war eine ausgezeichnete Gelegenheit, eine dienstgetrennte Architektur mit klar definierten Verantwortlichkeiten zu erkunden. Die kombinierte Nutzung von Express f√ºr die REST-API und einem dedizierten WebSocket-Server f√ºr die Echtzeit-Kommunikation erwies sich als elegante und leistungsstarke L√∂sung. Besonders gesch√§tzt habe ich die Integration von HTMX, das ein dynamisches Benutzererlebnis mit minimalem JavaScript bietet und gleichzeitig eine saubere serverseitige Architektur beibeh√§lt. In Zukunft m√∂chte ich tiefer in Skalierungsaspekte eintauchen und L√∂sungen wie Redis f√ºr die dienste√ºbergreifende Kommunikation erforschen."
  }
};

// Utiliser la langue demand√©e ou fran√ßais par d√©faut
const t = content[lang] || content.fr;

// Technologies utilis√©es
const technologies = [
  "Astro",
  "Alpine.js",
  "HTMX",
  "TailwindCSS",
  "Express",
  "WebSocket",
  "PostgreSQL",
  "MongoDB"
];

// Obtenir les projets pr√©c√©dent et suivant selon la langue
const getProjectUrl = (projectId: string) => `/${lang}/projects/${projectId}`;
const prevProject = {
  id: "objet",
  title: lang === "fr" ? 
    "Biblioth√®que d'objets - Quimper" :
    (lang === "en" ? 
      "Object Library - Quimper" : 
      "Objektbibliothek - Quimper")
};
const nextProject = {
  id: "portfolio",
  title: lang === "fr" ? 
    "Portfolio personnel √©co-responsable" :
    (lang === "en" ? 
      "Eco-friendly personal portfolio" : 
      "Umweltfreundliches pers√∂nliches Portfolio")
};
---

<Layout title={t.title} description={t.description} lang={lang}>
  <div class="container mx-auto px-4 py-8">
    <div class="mb-4">
      <a href={`/${lang}/projects`} class="text-text-muted hover:text-accent transition-colors">
        &larr; {t.allProjects}
      </a>
    </div>
    
    <!-- En-t√™te du projet -->
    <header class="mb-10">
      <h1 class="text-3xl font-bold mb-6 border-b border-accent pb-2">
        {t.projectTitle} (2025)
      </h1>
      <p class="text-lg mb-6 max-w-3xl">
        {t.projectIntro}
      </p>
    </header>
    
    <!-- Image principale du projet -->
    <div class="mb-10 bg-secondary bg-opacity-30 p-4 rounded-lg">
      <Picture
        src={esportImage}
        widths={[800, 1200, 1600]}
        sizes="(max-width: 1200px) 100vw, 1200px"
        formats={["avif", "webp", "jpg"]}
        alt={t.projectTitle}
        class="w-full rounded-lg"
      />
    </div>
    
    <!-- Aper√ßu du projet -->
    <section class="mb-10">
      <h2 class="text-2xl font-bold mb-4 text-accent">
        {t.overviewTitle}
      </h2>
      <p class="mb-6 max-w-3xl">
        {t.overviewText}
      </p>
      
      <!-- Actions principales -->
      <div class="flex flex-wrap gap-4 mb-8">
        <a 
          href="https://kewnewhimsy.github.io/esportify-f/"
          target="_blank"
          rel="noopener noreferrer"
          class="cta-button"
        >
          {t.visitSite}
        </a>
        <a 
          href="https://github.com/KewneWhimsy/esportify-f"
          target="_blank"
          rel="noopener noreferrer"
          class="btn-secondary"
        >
          {t.viewSourceCode}
        </a>
      </div>
    </section>
    
    <!-- Architecture du projet -->
    <section class="mb-10">
      <h2 class="text-2xl font-bold mb-6 text-accent">
        {t.architectureTitle}
      </h2>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
        <!-- Frontend -->
        <div class="bg-secondary bg-opacity-20 p-6 rounded-lg">
          <h3 class="text-xl font-semibold mb-4 flex items-center">
            <span>{t.frontendTitle}</span>
            <span class="ml-2">üñ•Ô∏è</span>
          </h3>
          <ul class="space-y-2">
            {t.frontendDetails.map(detail => (
              <li class="flex items-start">
                <span class="text-accent mr-2">‚Ä¢</span>
                <span>{detail}</span>
              </li>
            ))}
          </ul>
        </div>
        
        <!-- Backend -->
        <div class="bg-secondary bg-opacity-20 p-6 rounded-lg">
          <h3 class="text-xl font-semibold mb-4 flex items-center">
            <span>{t.backendTitle}</span>
            <span class="ml-2">‚öôÔ∏è</span>
          </h3>
          <ul class="space-y-2">
            {t.backendDetails.map(detail => (
              <li class="flex items-start">
                <span class="text-accent mr-2">‚Ä¢</span>
                <span>{detail}</span>
              </li>
            ))}
          </ul>
        </div>
      </div>
      
      
      
      <!-- Interaction des composants -->
      <div class="mb-8">
        <h3 class="text-xl font-semibold mb-4">
          {t.componentInteractionTitle}
        </h3>
        
        {t.componentInteractions.map((component, index) => (
          <div class="mb-6 border-l-4 border-accent pl-4 py-2">
            <h4 class="text-lg font-medium mb-2">{component.title}</h4>
            <p class="italic mb-2">{component.role}</p>
            <ul class="space-y-1">
              {component.responsibilities.map(resp => (
                <li class="flex items-start text-sm">
                  <span class="text-accent mr-2">‚Üí</span>
                  <span>{resp}</span>
                </li>
              ))}
            </ul>
          </div>
        ))}
      </div>
    </section>
    
    <!-- Images secondaires du projet (√† impl√©menter si disponibles) -->
    {esportImage2 && esportImage3 && (
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 my-8">
        <Picture
          src={esportImage2}
          widths={[400, 600, 900]}
          formats={["avif", "webp", "jpg"]}
          alt="Interface de chat de l'application e-sport"
          class="w-full h-full object-cover rounded-lg"
        />
        <Picture
          src={esportImage3}
          widths={[400, 600, 900]}
          formats={["avif", "webp", "jpg"]}
          alt="Gestion des tournois"
          class="w-full h-full object-cover rounded-lg"
        />
      </div>
    )}
    
    <!-- D√©fis techniques -->
    <section class="mb-10">
      <h2 class="text-2xl font-bold mb-6 text-accent">
        {t.challengesTitle}
      </h2>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        {t.challenges.map((challenge, index) => (
          <div class="bg-secondary bg-opacity-10 p-4 rounded-lg">
            <h3 class="font-medium mb-2">{challenge.title}</h3>
            <p class="text-sm">{challenge.description}</p>
          </div>
        ))}
      </div>
    </section>
    
    <!-- Solutions mises en ≈ìuvre -->
    <section class="mb-10">
      <h2 class="text-2xl font-bold mb-6 text-accent">
        {t.solutionsTitle}
      </h2>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        {t.solutions.map((solution, index) => (
          <div class="bg-secondary bg-opacity-20 p-5 rounded-lg">
            <h3 class="text-lg font-semibold mb-3">
              {solution.title}
            </h3>
            <p>{solution.description}</p>
          </div>
        ))}
      </div>
    </section>
    
    <!-- Image suppl√©mentaire du projet (√† impl√©menter si disponible) -->
    {esportImage4 && (
      <div class="mb-10">
        <Picture
          src={esportImage4}
          widths={[800, 1200]}
          formats={["avif", "webp", "jpg"]}
          alt="√âcran de chat en temps r√©el"
          class="w-full rounded-lg"
        />
      </div>
    )}
    
    <!-- Le√ßons apprises -->
    <section class="mb-10">
      <h2 class="text-2xl font-bold mb-4 text-accent">
        {t.lessonsTitle}
      </h2>
      <ul class="list-disc pl-6 space-y-2">
        {t.lessons.map(lesson => (
          <li>{lesson}</li>
        ))}
      </ul>
    </section>
    
    <!-- Performance et optimisations -->
    <section class="mb-10">
      <h2 class="text-2xl font-bold mb-6 text-accent">
        {t.performanceTitle}
      </h2>
      
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        {t.performance.map(perf => (
          <div class="bg-secondary bg-opacity-10 p-4 rounded-lg">
            <div class="flex justify-between mb-2">
              <h3 class="font-medium">{perf.metric}</h3>
              <span class="text-accent font-mono">{perf.value}</span>
            </div>
            <p class="text-sm text-text-muted">{perf.optimization}</p>
          </div>
        ))}
      </div>
    </section>
    
    <!-- Technologies utilis√©es -->
    <section class="mb-10">
      <h2 class="text-2xl font-bold mb-4 text-accent">
        {t.techTitle}
      </h2>
      
      <h3 class="text-lg font-semibold mb-3">
        {t.backendFrontendTitle}
      </h3>
      
      <div class="flex flex-wrap gap-2 mb-6">
        {technologies.slice(0, 4).map(tech => (
          <span class="px-3 py-1 border border-accent rounded-full text-accent transition-all hover:bg-accent-light">
            {tech}
          </span>
        ))}
      </div>
      
      <div class="flex flex-wrap gap-2 mb-6">
        {technologies.slice(4).map(tech => (
          <span class="px-3 py-1 bg-accent bg-opacity-20 rounded-full transition-all hover:bg-opacity-40">
            {tech}
          </span>
        ))}
      </div>
    </section>
    
    <!-- R√©flexion personnelle -->
    <section class="mb-10 bg-secondary bg-opacity-10 p-6 rounded-lg border-l-4 border-accent">
      <h2 class="text-2xl font-bold mb-4 text-accent">
        {t.reflectionTitle}
      </h2>
      <p class="italic">
        {t.reflectionText}
      </p>
    </section>
    
    <!-- Navigation entre projets -->
    <div class="border-t border-secondary pt-8 mt-12 flex justify-between">
      <a href={`/${lang}/objet`} class="btn-secondary">
        &larr; {t.prevProject}: {prevProject.title}
      </a>
      <a href={getProjectUrl(nextProject.id)} class="btn-secondary">
        {t.nextProject}: {nextProject.title} &rarr;
      </a>
    </div>
    
    <!-- CTA de contact -->
    <CtaDispo />
  </div>
</Layout>